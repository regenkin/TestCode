//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Learun.Util.Expression.Operand
{
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;

	public class Operand : Token
	{
        public enum OperandType { OperandUnknown, OperandBoolean, OperandNumber, OperandString };

        private Object m_value;

        public Operand()
        {
            this.m_value = 0.0f;
        }

        public Operand(OperandType type)
        {
            switch (type)
            {
                case OperandType.OperandBoolean: this.m_value = false; break;
                case OperandType.OperandNumber: this.m_value = 0.0f; break;
                case OperandType.OperandString: this.m_value = ""; break;
                default: throw new System.NotSupportedException();
            }
        }

        public Operand(Object val)
        {
            if (val is Operand)
                this.m_value = ((Operand)val).m_value;
            else
                this.m_value = val;
        }

        public override bool IsOperand
        {
            get
            {
                return true;
            }
        }

        public OperandType Type
        {
            get
            {
                if (m_value is bool)
                    return OperandType.OperandBoolean;
                else
                    if (m_value is float)
                        return OperandType.OperandNumber;
                    else
                        if (m_value is string)
                            return OperandType.OperandString;
                        else
                            return OperandType.OperandUnknown;
            }
        }

		public virtual float AsFloat
		{
			get {
                if (m_value is float)
                    return (float)m_value;
                else
                    if (m_value is bool)
                        return (bool)m_value ? 1.0f : 0.0f;
                    else
                        if (m_value is string)
                        {
                            float val = 0.0f;

                            if (float.TryParse((string)m_value, out val))
                                return val;
                            else
                                return 0.0f;
                        }

                return 0.0f;
            }

			protected set {
                m_value = (new Operand(value)).AsFloat;
            }
		}

		public virtual bool AsBoolean
		{
            get {
                if (m_value is float)
                    return (float)m_value != 0 ? true : false;
                else
                    if (m_value is bool)
                        return (bool)m_value;
                    else
                        if (m_value is string)
                        {
                            bool val = true;

                            if (bool.TryParse((string)m_value, out val))
                                return val;
                            else
                                return false;
                        }

                return false;
            }

            protected set
            {
                m_value = (new Operand(value)).AsBoolean;
            }
		}

		public virtual string AsString
		{
            get { return m_value.ToString(); }
            protected set
            {
                m_value = (new Operand(value)).AsString;
            }
		}

		public override string ToString()
		{
            return m_value.ToString();
		}

		public virtual int CompareTo(Operand that)
		{
            if (this.Equals(that))
                return 0;

            if (this.Type == that.Type)
            {
                if (this.Type != OperandType.OperandString)
                {
                    if (this.AsFloat == that.AsFloat)
                        return 0;
                    else
                        if (this.AsFloat < that.AsFloat)
                            return -1;
                        else
                            return 1;
                }
                else
                    return this.AsString.CompareTo(that.AsString);
            }
            else
            {
                if ((this.Type == OperandType.OperandBoolean || this.Type == OperandType.OperandNumber) &&
                    (that.Type == OperandType.OperandBoolean || that.Type == OperandType.OperandNumber))
                {
                    if (this.AsFloat == that.AsFloat)
                        return 0;
                    else
                        if (this.AsFloat < that.AsFloat)
                            return -1;
                        else
                            return 1;
                }
                else
                    return this.AsString.CompareTo(that.AsString);
            }
		}

        /***********************************************
         *  Operator Override
         *  ********************************************/
        
        public static Operand operator + (Operand left, Operand right)
        {
            if (left.Type == OperandType.OperandString || right.Type == OperandType.OperandString)
                return new Operand(left.AsString + right.AsString);
            else
                if (left.Type == OperandType.OperandNumber || right.Type == OperandType.OperandNumber)
                    return new Operand(left.AsFloat + right.AsFloat);
                else
                    return new Operand(left.AsBoolean && right.AsBoolean);
        }

        public static Operand operator -(Operand left, Operand right)
        {
            return new Operand(left.AsFloat - right.AsFloat);
        }

        public static Operand operator *(Operand left, Operand right)
        {
            return new Operand(left.AsFloat * right.AsFloat);
        }

        public static Operand operator /(Operand left, Operand right)
        {
            if (right.AsFloat == 0.0f)
                throw new System.DivideByZeroException();
            else
                return new Operand(left.AsFloat / right.AsFloat);
        }

        public static Operand operator %(Operand left, Operand right)
        {
            if (right.AsFloat == 0.0f)
                throw new System.DivideByZeroException();
            else
                return new Operand(left.AsFloat % right.AsFloat);
        }

        public static Operand operator >>(Operand left, int right)
        {
            return new Operand((int)left.AsFloat >> right);
        }

        public static Operand operator <<(Operand left, int right)
        {
            return new Operand((int)left.AsFloat << right);
        }

        public static Operand operator >(Operand left, Operand right)
        {
            return new Operand(left.CompareTo(right) > 0);
        }

        public static Operand operator >=(Operand left, Operand right)
        {
            return new Operand(left.CompareTo(right) >= 0);
        }

        public static Operand operator <(Operand left, Operand right)
        {
            return new Operand(left.CompareTo(right) < 0);
        }

        public static Operand operator <=(Operand left, Operand right)
        {
            return new Operand(left.CompareTo(right) <= 0);
        }

        public static Operand operator &(Operand left, Operand right)
        {
            return new Operand((int)left.AsFloat & (int)right.AsFloat);
        }

        public static Operand operator |(Operand left, Operand right)
        {
            return new Operand((int)left.AsFloat | (int)right.AsFloat);
        }

        public static Operand operator !(Operand left)
        {
            return new Operand(!left.AsBoolean);
        }

        public static Operand operator ~(Operand left)
        {
            return new Operand(~(int)left.AsFloat);
        }

        public static Operand operator ^(Operand left, Operand right)
        {
            return new Operand((int)left.AsFloat ^ (int)left.AsFloat);
        }
	}
}

