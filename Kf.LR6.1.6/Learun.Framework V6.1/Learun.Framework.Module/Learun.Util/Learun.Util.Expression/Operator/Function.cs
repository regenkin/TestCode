//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Learun.Util.Expression.Operator
{
	using Learun.Util.Expression.Operand;
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;

	public class Function : Operator
	{
        public static Dictionary<string, Type> GlobalFunctionDictionary = new Dictionary<string, Type>();

        public static bool IsSupportedFunction(string funcName)
        {
            return GlobalFunctionDictionary.ContainsKey(funcName.ToLower());
        }

        public static Function CreateFunction(string funcName)
        {
            if (GlobalFunctionDictionary.Count == 0)
            {
                new Sum();
                new Average();
                new Power();
            }

            if (!GlobalFunctionDictionary.ContainsKey(funcName.ToLower()))
                throw new System.NotImplementedException("Function '" + funcName + "' not implemented.");

            Type funcType = GlobalFunctionDictionary[funcName.ToLower()];

            System.Reflection.ConstructorInfo ctor = funcType.GetConstructor(new Type[]{});

            return (Function)ctor.Invoke(new Object[] { });
        }

        private uint m_minArgumentNum = 0;
        private uint m_maxArgumentNum = 65535;
        private List<Operand> m_arguments;

        public Function(string funcName, Operator.PriorityType prio)
            : base(funcName.ToLower(), prio)
        {
            RegisterFunction(this);
            m_arguments = new List<Operand>();
        }

        public static void RegisterFunction(Function func)
        {
            if (!GlobalFunctionDictionary.ContainsKey(func.TokenName.ToLower()))
            {
                GlobalFunctionDictionary.Add(func.TokenName.ToLower(), func.GetType());
            }
        }
        public override bool IsFunction
        {
            get
            {
                return true;
            }
        }

		public virtual uint MinArgumentNum
		{
            get { return m_minArgumentNum; }
            protected set { m_minArgumentNum = value; }
		}

		public virtual uint MaxArgumentNum
		{
            get { return m_maxArgumentNum; }
            protected set { m_maxArgumentNum = value; }
		}

        public override Operand Evaluate(Operand[] operands)
        {
            if (operands.Count() < MinArgumentNum || operands.Count() > MaxArgumentNum)
                throw new System.NotSupportedException("Too many or few arguments for function '" + this.TokenName + "'.");

            return null;
        }
	}
}

